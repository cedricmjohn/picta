\documentclass[12pt]{article}
\usepackage[a4paper, total={6in, 8in}, margin=1in]{geometry}
\usepackage[sorting=none]{biblatex}
\usepackage{lmodern}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{float}
\usepackage[table,x11names]{xcolor}
\setcounter{secnumdepth}{4}
\usepackage{pgfgantt}
\usepackage{lscape}

\addbibresource{References.bib}

\begin{document}
	%==================================
	%	TITLE PAGE
	%==================================
\begin{titlepage}
	\begin{center}
		\vspace*{1cm}
		
		Imperial College London \\
		Department of Earth Science and Engineering \\
		MSc in Applied Computational Science and Engineering
		
		\vspace{1cm}
		
		Independent Research Project \\
		Project Plan
		
		
		\vspace{1cm}
		
		
		{\fontsize{18}{104}\selectfont \textbf{ CoNuS-Viz: A Visualization Package for the Concurrent Library for Numerical Simulations}}

		
		\vspace{1cm}
		
		by \\ 
		Fazal Khan
		
		\vspace{1cm}
		
		Supervisor: \\
		Professor Cédric John
		
		\vspace{1cm}
		
		Email: \\
		fk4517@ic.ac.uk
		
		\vspace{1cm}
		
		GitHub login: \\
		acse-fk4517
		
		\vspace{1.0cm}
		
		June 2020
		
	\end{center}
\end{titlepage}	
%==================================
%	Introduction
%==================================
\section{Introduction}

\subsection{Forward Modelling}

Many real-world scientific processes, such as fluid-flow or infectious diseases may be formulated as a model that evolves with time. Formulating a process this way allows it to be simulated using computational techniques. Suppose $\vec y$ denotes the variables of interest stacked in a vector, then a forward model describing their evolution with respect to time may be written as:

\begin{center}
	\begin{equation}
	\vec y_{t+1} = f(t, ~\vec y_t)
	\end{equation}
\end{center}

From this we can see that in order to update the variables of interest, $\vec y_t$, we must consider both time, $t$ and the previous state of the variables of interest, $\vec y_{t-1}$.


As mentioned, this general technique can be applied in many different fields. As a concrete example, consider one such field known as Stratigraphy. Stratigraphy is concerned with the processes which lead to the organization of rocks in space and time. Stratigraphic Forward Models (SFM) are forward models which have been used to simulate realistic stratigraphic processes based on a set of reasonable geologic parameter values, such as tectonic movement and erosion \cite{10.2110/pec.99.62.0069}.

When studying stratigraphic observational data, it is often important to understand what set of initial geological conditions may have caused the stratigraphic patterns in the observations. Problems of this type can be generally classified as inverse problems \cite{10.1260/0144598011492363}. SFMs can be used to generate a set of outputs which in turn are compared to observations. Outputs are generated systematically for a range of initial parameter values, and those outputs which are close to the observations within a pre-defined bound are then taken as solutions to this inverse problem. Used in this way SFMs are an integral part of solving inversion problems in stratigraphy. More generally, solving inverse problems in this way can be useful for many other domains ranging from finance to physics.


\subsection{Computational Intensity of Large Forward Models}
Large forward models are computationally intensive methods which may require many outputs to find a satisfactory solution. For example in order to solve inverse problems, not only are many outputs generated, but the set of input geological parameters, $\vec y_i$ is often also very large too \cite{10.1260/0144598011492363}.

For these reasons computational techniques that can deal with large models efficiently are very important in practice. One way to address this is to use concurrency and parallelism when performing calculations on the underlying data. Such techniques have been used in scientific modelling for increasing performance and reducing computation time. Domains ranging from biophysical modelling to computational fluid dynamics have benefited from technologies such as GPUs that allows these techniques to be more readily exploited \cite{4490127}.

\subsection{The Concurrent Library for Numerical Simulations (CoNuS)}
CoNuS is an experimental open-source library developed by Professor Cédric John from the Carbonate Research Group at Imperial College London. The library is written in the Scala programming language and has two general aims:

\begin{enumerate}
\item \textbf{Abstraction}: Abstract away unnecessary implementation details from the user so they can focus on the modelling. \\
\item \textbf{Performance}: Be performant enough to run large, concurrent models in a reasonable amount of time.
\end{enumerate}

\subsubsection{Abstraction}
Conventional forward models generally require users to define a grid of variables, some type of mathematical equation that defines how variables evolve with time, and a loop to actually carry out calculations. CoNuS abstracts away these common mechanics of forward models so that users from any discipline, regardless of their programming experience, can compose models by focusing on the mathematical basis for how variables evolve. Users essentially define equation (1), and let the model run.

\subsubsection{Performance}
CoNuS leverages the Scala programming language and functional programming techniques to enhance performance and program correctness. Functional programming techniques are excellent at creating data recursion schemes that can exploit concurrency and parallelism; an example is Google's famous MapReduce algorithm which processes large datasets in parallel \cite{LAMMEL20081}. 

Since it is written in Scala, CoNuS benefits from several language features that make writing concurrent code easier. Scala is a statically typed, compiled language that targets the Java Virtual Machine (JVM) \cite{scala}. A strong type system can be very useful in designing software as it allows a programmer to discover variants and trigger generalizations that simplify design \cite{LAMMEL20081}. 

Scala also combines both object-orientated and functional programming concepts to create highly expressive programs that can support many levels of abstraction over the underlying computation. One such abstraction is the Scala actor model which allows concurrent code to be written ergonomically in a type-safe manner. The actor model was introduced to deal with the JVMs shared-memory thread model, which suffered from high memory consumption and context switching costs \cite{haller_odersky_2009}. The Scala actors library has since been deprecated and replaced by the Akka library, which is built on the same concept and allows code to be run on clusters \cite{akka}. Making use of actors on clusters is on the roadmap for the CoNuS library.

\section{Project Aim}
As CoNuS is experimental, it currently lacks an integrated visualization library which can plot the results of models. The aim of this independent research project will be to design and build a visualization library, CoNuS-Viz, will allow users to visualize CoNuS models. In addition, this library will also provide more general plotting functions, such as those found in Python's matplotlib \cite{matplotlib}.


\subsection{Schedule}
In this section I will outline the envisaged project schedule. Some of the items in the schedule were already underway as of writing.

\subsubsection{Phase 1: Preparation}

\textbf{i. Literature Review}

I will review literature on Forward Modelling, Data Visualization and Functional Programming. 

As of writing I have completed the literature review on Forward Modelling, and understand the context of the CoNuS-Viz. \\

\textbf{ii. Review Existing Visualization Libraries}

For this part I will review the existing libraries that exist on Scala and the JVM, taking note of their limitations and strengths. This part will critically inform my project strategy. \\

\textbf{iii. Learn Functional Programming Techniques}

Functional programming is a new way of approaching programming. Scala is also a complex language, and so this part is crucial for me to get up to speed in order to leverage Scala effectively. \\


\textbf{iv. Implement Basic Library Structure}

Based on the foundations built in the above three phases, I will begin to design and implement basic functionality to get the project going. \\

\textbf{v. Write Project Plan}

I will begin writing the project plan ready for submission by the 25th of June. \\


\subsubsection{Phase 2: Execution}

\textbf{i. Design Advanced Components of Library}

.... \\

\textbf{ii. Learn Further Library Design Principles}

.... \\

\textbf{iii. Write Summary of Work Done So Far}

.... \\

\textbf{iv. Review Codebase}

.... \\

\subsubsection{Phase 3: Summary}

\textbf{i. Test Library}

.... \\

\textbf{ii. Review Summaries}

.... \\

\textbf{iii. Write Independent Research Report}

.... \\

\subsubsection{Phase 3: Summary}

\textbf{i. Meet Supervisor}

.... \\

\textbf{ii. Write Unit Tests}

.... \\



\pagebreak
\printbibliography

\end{document}